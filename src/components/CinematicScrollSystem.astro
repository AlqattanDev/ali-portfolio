---
// Advanced Cinematic Scroll System for Portfolio
---

<!-- Smooth Scroll Progress Indicator -->
<div class="scroll-progress">
  <div class="progress-bar"></div>
</div>

<!-- Custom Cursor -->
<div class="custom-cursor">
  <div class="cursor-dot"></div>
  <div class="cursor-outline"></div>
</div>

<!-- Scroll Sections Container -->
<div class="cinematic-container">
  <slot />
</div>

<script>
  async function initCinematicSystem() {
    try {
      const { gsap } = await import('gsap');
      const { ScrollTrigger } = await import('gsap/ScrollTrigger');
      const { ScrollSmoother } = await import('gsap/ScrollSmoother');
      
      gsap.registerPlugin(ScrollTrigger, ScrollSmoother);

      // ===== SMOOTH SCROLLING SYSTEM =====
      let smoother = ScrollSmoother.create({
        wrapper: '.cinematic-container',
        content: '.cinematic-container > *',
        smooth: 2,
        effects: true,
        smoothTouch: 0.1,
        normalizeScroll: true,
        ignoreMobileResize: true
      });

      // ===== PROGRESS INDICATOR =====
      gsap.to('.progress-bar', {
        scaleX: 1,
        ease: 'none',
        scrollTrigger: {
          trigger: 'body',
          start: 'top top',
          end: 'bottom bottom',
          scrub: 0.5
        }
      });

      // ===== CINEMATIC SECTION REVEALS =====
      gsap.utils.toArray('.section').forEach((section, index) => {
        // Main section reveal
        gsap.fromTo(section, 
          {
            opacity: 0,
            y: 100,
            scale: 0.95,
            filter: 'blur(10px)'
          },
          {
            opacity: 1,
            y: 0,
            scale: 1,
            filter: 'blur(0px)',
            duration: 1.5,
            ease: 'power2.out',
            scrollTrigger: {
              trigger: section,
              start: 'top 85%',
              end: 'top 30%',
              toggleActions: 'play none none reverse'
            }
          }
        );

        // Parallax layers within sections
        const parallaxElements = section.querySelectorAll('.entry, .skill-item, .tech-tag');
        parallaxElements.forEach((el, i) => {
          gsap.fromTo(el,
            {
              y: 50 + (i * 10),
              opacity: 0,
              rotateX: -15
            },
            {
              y: 0,
              opacity: 1,
              rotateX: 0,
              duration: 1.2,
              delay: i * 0.1,
              ease: 'power3.out',
              scrollTrigger: {
                trigger: el,
                start: 'top 90%',
                end: 'top 50%',
                toggleActions: 'play none none reverse'
              }
            }
          );
        });
      });

      // ===== TEXT MORPHING EFFECTS =====
      gsap.utils.toArray('.section-title').forEach(title => {
        const chars = title.textContent.split('');
        title.innerHTML = '';
        
        chars.forEach(char => {
          const span = document.createElement('span');
          span.textContent = char === ' ' ? '\u00A0' : char;
          span.style.display = 'inline-block';
          title.appendChild(span);
        });

        gsap.fromTo(title.children,
          {
            y: 100,
            rotateX: -90,
            opacity: 0
          },
          {
            y: 0,
            rotateX: 0,
            opacity: 1,
            duration: 0.8,
            stagger: 0.02,
            ease: 'power3.out',
            scrollTrigger: {
              trigger: title,
              start: 'top 85%',
              toggleActions: 'play none none reverse'
            }
          }
        );
      });

      // ===== LAYERED PARALLAX DEPTH =====
      gsap.utils.toArray('.execute-protocol, .checksum').forEach((element, index) => {
        const speed = 0.5 + (index * 0.2);
        
        gsap.to(element, {
          yPercent: -20 * speed,
          ease: 'none',
          scrollTrigger: {
            trigger: element,
            start: 'top bottom',
            end: 'bottom top',
            scrub: 1.5
          }
        });
      });

      // ===== MAGNETIC SECTION SNAPPING =====
      gsap.utils.toArray('.section').forEach(section => {
        ScrollTrigger.create({
          trigger: section,
          start: 'top 20%',
          end: 'bottom 80%',
          onToggle: (self) => {
            if (self.isActive) {
              gsap.to(section, {
                scale: 1.02,
                duration: 0.3,
                ease: 'power2.out'
              });
            } else {
              gsap.to(section, {
                scale: 1,
                duration: 0.3,
                ease: 'power2.out'
              });
            }
          }
        });
      });

      // ===== INTERACTIVE CURSOR =====
      const cursor = document.querySelector('.custom-cursor');
      const cursorDot = cursor.querySelector('.cursor-dot');
      const cursorOutline = cursor.querySelector('.cursor-outline');

      let mouseX = 0, mouseY = 0;
      let outlineX = 0, outlineY = 0;

      document.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        gsap.to(cursorDot, {
          x: mouseX,
          y: mouseY,
          duration: 0.1,
          ease: 'power2.out'
        });
      });

      gsap.ticker.add(() => {
        outlineX += (mouseX - outlineX) * 0.15;
        outlineY += (mouseY - outlineY) * 0.15;
        
        gsap.set(cursorOutline, {
          x: outlineX,
          y: outlineY
        });
      });

      // Cursor interactions
      document.querySelectorAll('a, .interactive').forEach(el => {
        el.addEventListener('mouseenter', () => {
          gsap.to([cursorDot, cursorOutline], {
            scale: 2,
            duration: 0.3,
            ease: 'power2.out'
          });
        });
        
        el.addEventListener('mouseleave', () => {
          gsap.to([cursorDot, cursorOutline], {
            scale: 1,
            duration: 0.3,
            ease: 'power2.out'
          });
        });
      });

      // ===== FLOATING ELEMENTS =====
      gsap.utils.toArray('.tech-tag').forEach((tag, index) => {
        gsap.to(tag, {
          y: 'random(-10, 10)',
          x: 'random(-5, 5)',
          rotation: 'random(-2, 2)',
          duration: 'random(3, 5)',
          repeat: -1,
          yoyo: true,
          ease: 'sine.inOut',
          delay: index * 0.1
        });
      });

      // ===== PERFORMANCE OPTIMIZATIONS =====
      ScrollTrigger.addEventListener('refreshInit', () => {
        gsap.set('.section, .entry, .skill-item', { clearProps: 'all' });
      });

      // Cleanup
      window.addEventListener('beforeunload', () => {
        ScrollTrigger.getAll().forEach(trigger => trigger.kill());
        smoother?.kill();
      });

    } catch (error) {
      console.warn('GSAP ScrollSmoother not available, using basic animations:', error);
      // Fallback to basic scroll animations if ScrollSmoother isn't available
      initBasicScrollAnimations();
    }
  }

  async function initBasicScrollAnimations() {
    const { gsap } = await import('gsap');
    const { ScrollTrigger } = await import('gsap/ScrollTrigger');
    
    gsap.registerPlugin(ScrollTrigger);

    // Basic reveal animations as fallback
    gsap.utils.toArray('.section').forEach(section => {
      gsap.fromTo(section, 
        { opacity: 0, y: 50 },
        {
          opacity: 1,
          y: 0,
          duration: 1,
          scrollTrigger: {
            trigger: section,
            start: 'top 80%',
            toggleActions: 'play none none reverse'
          }
        }
      );
    });
  }

  // Initialize system
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCinematicSystem);
  } else {
    initCinematicSystem();
  }
</script>

<style>
  /* ===== SCROLL PROGRESS ===== */
  .scroll-progress {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 3px;
    z-index: 9999;
    background: rgba(0, 0, 0, 0.1);
  }

  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
    transform-origin: left;
    transform: scaleX(0);
    box-shadow: 0 0 10px var(--accent-primary);
  }

  /* ===== CUSTOM CURSOR ===== */
  .custom-cursor {
    position: fixed;
    pointer-events: none;
    z-index: 9998;
    mix-blend-mode: difference;
  }

  .cursor-dot {
    position: absolute;
    width: 6px;
    height: 6px;
    background: var(--accent-primary);
    border-radius: 50%;
    transform: translate(-50%, -50%);
  }

  .cursor-outline {
    position: absolute;
    width: 30px;
    height: 30px;
    border: 1px solid var(--accent-primary);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.3;
  }

  /* ===== CINEMATIC CONTAINER ===== */
  .cinematic-container {
    overflow-x: hidden;
  }

  /* ===== ENHANCED SECTION STYLING ===== */
  .section {
    transform-style: preserve-3d;
    perspective: 1000px;
    will-change: transform, opacity;
    backface-visibility: hidden;
  }

  .section-title {
    perspective: 1000px;
    transform-style: preserve-3d;
  }

  .section-title span {
    transform-style: preserve-3d;
    will-change: transform;
  }

  /* ===== FLOATING ELEMENTS ===== */
  .tech-tag {
    will-change: transform;
    backface-visibility: hidden;
  }

  /* ===== MOBILE OPTIMIZATIONS ===== */
  @media (max-width: 768px) {
    .custom-cursor {
      display: none;
    }
    
    .scroll-progress {
      height: 2px;
    }
  }

  /* ===== PRINT MODE ===== */
  body.print-view .scroll-progress,
  body.print-view .custom-cursor {
    display: none;
  }

  body.print-view .section {
    transform: none !important;
    opacity: 1 !important;
  }

  /* ===== REDUCED MOTION ===== */
  @media (prefers-reduced-motion: reduce) {
    .scroll-progress,
    .custom-cursor {
      display: none;
    }
    
    .section,
    .section-title span,
    .tech-tag {
      transform: none !important;
      opacity: 1 !important;
      animation: none !important;
    }
  }

  /* ===== PERFORMANCE HINTS ===== */
  .section,
  .entry,
  .skill-item,
  .tech-tag {
    will-change: transform, opacity;
    transform: translate3d(0, 0, 0);
  }
</style>